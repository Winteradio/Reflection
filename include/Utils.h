#ifndef __REFLECTION_UTILS_H__
#define __REFLECTION_UTILS_H__

#include <string>

namespace Reflection
{
	namespace Utils
	{
		/**
		 * @brief	Compile-time check for type equality.
		 * @tparam	T The first type to compare.
		 * @tparam	U The second type to compare.
		 */
		template<typename T, typename U>
		struct IsSame
		{
			static constexpr bool value = false;
		};

		/**
		 * @brief	Compile-time check for type equality specialization when both types are the same.
		 * @tparam	T The type to compare.
		 */
		template<typename T>
		struct IsSame<T, T>
		{
			static constexpr bool value = true;
		};

		/**
		 * @brief	Enables a type only if the given boolean condition is true.
		 * @tparam	T The boolean condition.
		 */
		template<bool T>
		struct IsEnabled;

		/**
		 * @brief	Enables a type only if the given boolean condition is true specialization for true condition.
		 * @tparam	T The boolean condition.
		 */
		template<>
		struct IsEnabled<true>
		{
			using Type = void;
		};

		/**
		 * @brief	Alias template for IsEnabled to simplify usage.
		 * @tparam	Condition The boolean condition.
		 */
		template<bool T>
		using IsEnabled_t = typename IsEnabled<T>::Type;

		/**
		 * @brief	Helper struct to wrap types for SFINAE detection.
		 * @tparam	... Types to wrap.
		 */
		template<typename...>
		struct TypeWrapper
		{
			using Type = void;
		};

		/**
		 * @brief	SFINAE helper to check if a type has been registered with the Reflection System.
		 * @details	It checks for the existence of the 'ThisType' typedef, which is automatically 
		 * 			generated by the GENERATE() macro. This allows other systems to know 
		 * 			if a class supports reflection at compile-time.
		 */
		template<typename T, typename U = void>
		struct TypeDetector
		{
			using Type = void;
		};

		/**
		 * @brief	Specialization of TypeDetector when T has a nested ThisType typedef.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct TypeDetector<T, typename TypeWrapper<typename T::ThisType>::Type>
		{
			using Type = typename T::ThisType;
		};

		/**
		 * @brief	Removes pointer qualifiers from a type.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T*>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for const and volatile pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T* const>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for volatile pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T* volatile>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for const volatile pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T* const volatile>
		{
			using Type = T;
		};

		/**
		 * @brief	Removes reference qualifiers from a type.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for const and volatile reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<const T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for volatile reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<volatile T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for const volatile reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<const volatile T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Removes const qualifiers from a type.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveConst
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveConst for const types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveConst<const T>
		{
			using Type = T;
		};

		/**
		 * @brief	Alias templates for common type transformations.
		 * @tparam	T The type to transform.
		 */
		template<typename T>
		using RemovePointer_t = typename RemovePointer<T>::Type;

		/**
		 * @brief	Alias templates for common type transformations.
		 * @tparam	T The type to transform.
		 */
		template<typename T>
		using RemoveReference_t = typename RemoveReference<T>::Type;

		/**
		 * @brief	Alias templates for common type transformations.
		 * @tparam	T The type to transform.
		 */
		template<typename T>
		using RemoveConst_t = typename RemoveConst<T>::Type;

		/**
		 * @brief	Alias template to obtain the pure type by removing pointer, reference, and const qualifiers.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		using PureType_t = RemovePointer_t<RemoveReference_t<RemoveConst_t<T>>>;

		/**
		 * @brief	Compile-time check to determine if a type is a pointer.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct IsPointer
		{
			static constexpr bool value = !IsSame<T, RemovePointer_t<T>>::value;
		};

		/**
		 * @brief	Compile-time check to determine if a type is a reference.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct IsReference
		{
			static constexpr bool value = !IsSame<T, RemoveReference_t<T>>::value;
		};

		/**
		 * @brief	Compile-time check to determine if a type is const-qualified.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct IsConst
		{
			static constexpr bool value = !IsSame<T, RemoveConst_t<T>>::value;
		};

		/**
		 * @brief	Conditional type selection based on a boolean condition.
		 * @tparam	Condition The boolean condition.
		 * @tparam	T The type if the condition is true.
		 * @tparam	U The type if the condition is false.
		 */
		template<bool Condition, typename T, typename U>
		struct Conditional
		{
			using Type = T;
		};

		/**
		 * @brief	Conditional type selection specialization for false condition.
		 * @tparam	T The type if the condition is true.
		 * @tparam	U The type if the condition is false.
		 */
		template<typename T, typename U>
		struct Conditional<false, T, U>
		{
			using Type = U;
		};

		template<bool Condition, typename T, typename U>
		using Conditional_t = typename Conditional<Condition, T, U>::Type;

		template<typename T>
		void CheckPointer(T*) 
		{};

		template<typename Parent, typename Child, typename U = void>
		struct IsBase
		{
			static constexpr bool value = false;
		};

		template<typename Parent, typename Child>
		struct IsBase<Parent, Child, decltype(CheckPointer<Parent>(static_cast<Child*>(nullptr)))>
		{
			static constexpr bool value = true;
		};

		template<typename T, typename = void>
		struct IteratorTraits;

		template<typename T>
		struct IteratorTraits<T, typename TypeWrapper<typename T::Iterator, typename T::ConstIterator>::Type>
		{
			using Iterator = typename T::Iterator;
			using ConstIterator = typename T::ConstIterator;
		};

		template<typename T>
		struct IteratorTraits<T, typename TypeWrapper<typename T::iterator, typename T::const_iterator>::Type>
		{
			using Iterator = typename T::iterator;
			using ConstIterator = typename T::const_iterator;
		};

		template<typename T, typename = void>
		struct KeyTraits;

		template<typename T>
		struct KeyTraits<T, typename TypeWrapper<typename T::key_type>::Type>
		{
			using KeyType = typename T::key_type;
		};

		template<typename T>
		struct KeyTraits<T, typename TypeWrapper<typename T::KeyType>::Type>
		{
			using KeyType = typename T::KeyType;
		};

		template<typename T, typename = void>
		struct ValueTraits;

		template<typename T>
		struct ValueTraits<T, typename TypeWrapper<typename T::value_type>::Type>
		{
			using ValueType = typename T::value_type;
		};

		template<typename T>
		struct ValueTraits<T, typename TypeWrapper<typename T::ValueType>::Type>
		{
			using ValueType = typename T::ValueType;
		};

		template<typename T, typename = void>
		struct MappedTraits;

		template<typename T>
		struct MappedTraits<T, typename TypeWrapper<typename T::mapped_type>::Type>
		{
			using MappedType = typename T::mapped_type;
		};

		template<typename T>
		struct MappedTraits<T, typename TypeWrapper<typename T::MappedType>::Type>
		{
			using MappedType = typename T::MappedType;
		};

		template<typename T, typename = void>
		struct HasIterator
		{
			static constexpr bool value = false;
		};

		template<typename T>
		struct HasIterator<T, typename Utils::TypeWrapper<typename IteratorTraits<T>::Iterator>::Type>
		{
			static constexpr bool value = true;
		};

		template<typename T, typename = void>
		struct HasKey
		{
			static constexpr bool value = false;
		};

		template<typename T>
		struct HasKey<T, typename Utils::TypeWrapper<typename KeyTraits<T>::KeyType>::Type>
		{
			static constexpr bool value = true;
		};

		template<typename T, typename = void>
		struct HasMapped
		{
			static constexpr bool value = false;
		};

		template<typename T>
		struct HasMapped<T, typename Utils::TypeWrapper<typename MappedTraits<T>::MappedType>::Type>
		{
			static constexpr bool value = true;
		};

		template<typename T>
		constexpr bool IsArray = HasIterator<T>::value && !HasKey<T>::value && !HasMapped<T>::value;

		template<typename T>
		constexpr bool IsSet = HasIterator<T>::value && HasKey<T>::value && !HasMapped<T>::value;

		template<typename T>
		constexpr bool IsMap = HasIterator<T>::value && HasKey<T>::value && HasMapped<T>::value;

		template<typename T>
		struct MemberTraits;

		template<typename Class, typename Property>
		struct MemberTraits<Property Class::*>
		{
			using ClassType = Class;
			using PropertyType = Property;
		};
	};
};
#endif // __REFLECTION_UTILS_H__