#ifndef __REFLECTION_UTILS_H__
#define __REFLECTION_UTILS_H__

#include <string>

namespace Reflection
{
	namespace Utils
	{
		/**
		 * @brief	Compile-time check for type equality.
		 * @tparam	T The first type to compare.
		 * @tparam	U The second type to compare.
		 */
		template<typename T, typename U>
		struct IsSame
		{
			static constexpr bool value = false;
		};

		/**
		 * @brief	Compile-time check for type equality specialization when both types are the same.
		 * @tparam	T The type to compare.
		 */
		template<typename T>
		struct IsSame<T, T>
		{
			static constexpr bool value = true;
		};

		/**
		 * @brief	Enables a type only if the given boolean condition is true.
		 * @tparam	T The boolean condition.
		 */
		template<bool T>
		struct IsEnabled;

		/**
		 * @brief	Enables a type only if the given boolean condition is true specialization for true condition.
		 * @tparam	T The boolean condition.
		 */
		template<>
		struct IsEnabled<true>
		{
			using Type = void;
		};

		/**
		 * @brief	Alias template for IsEnabled to simplify usage.
		 * @tparam	Condition The boolean condition.
		 */
		template<bool T>
		using IsEnabled_t = typename IsEnabled<T>::Type;

		/**
		 * @brief	Helper struct to wrap types for SFINAE detection.
		 * @tparam	... Types to wrap.
		 */
		template<typename...>
		struct TypeWrapper
		{
			using Type = void;
		};

		/**
		 * @brief	SFINAE helper to check if a type has been registered with the Reflection System.
		 * @details	It checks for the existence of the 'ThisType' typedef, which is automatically 
		 * 			generated by the GENERATE() macro. This allows other systems to know 
		 * 			if a class supports reflection at compile-time.
		 */
		template<typename T, typename U = void>
		struct TypeDetector
		{
			using Type = void;
		};

		/**
		 * @brief	Specialization of TypeDetector when T has a nested ThisType typedef.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct TypeDetector<T, typename TypeWrapper<typename T::ThisType>::Type>
		{
			using Type = typename T::ThisType;
		};

		/**
		 * @brief	Removes pointer qualifiers from a type.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T*>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for const and volatile pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T* const>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for volatile pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T* volatile>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemovePointer for const volatile pointer types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemovePointer<T* const volatile>
		{
			using Type = T;
		};

		/**
		 * @brief	Removes reference qualifiers from a type.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for const and volatile reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<const T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for volatile reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<volatile T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveReference for const volatile reference types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveReference<const volatile T&>
		{
			using Type = T;
		};

		/**
		 * @brief	Removes const qualifiers from a type.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveConst
		{
			using Type = T;
		};

		/**
		 * @brief	Specializations of RemoveConst for const types.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		struct RemoveConst<const T>
		{
			using Type = T;
		};

		/**
		 * @brief	Alias templates for common type transformations.
		 * @tparam	T The type to transform.
		 */
		template<typename T>
		using RemovePointer_t = typename RemovePointer<T>::Type;

		/**
		 * @brief	Alias templates for common type transformations.
		 * @tparam	T The type to transform.
		 */
		template<typename T>
		using RemoveReference_t = typename RemoveReference<T>::Type;

		/**
		 * @brief	Alias templates for common type transformations.
		 * @tparam	T The type to transform.
		 */
		template<typename T>
		using RemoveConst_t = typename RemoveConst<T>::Type;

		/**
		 * @brief	Alias template to obtain the pure type by removing pointer, reference, and const qualifiers.
		 * @tparam	T The type to process.
		 */
		template<typename T>
		using PureType_t = RemovePointer_t<RemoveReference_t<RemoveConst_t<T>>>;

		/**
		 * @brief	Compile-time check to determine if a type is a pointer.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct IsPointer
		{
			static constexpr bool value = !IsSame<T, RemovePointer_t<T>>::value;
		};

		/**
		 * @brief	Compile-time check to determine if a type is a reference.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct IsReference
		{
			static constexpr bool value = !IsSame<T, RemoveReference_t<T>>::value;
		};

		/**
		 * @brief	Compile-time check to determine if a type is const-qualified.
		 * @tparam	T The type to check.
		 */
		template<typename T>
		struct IsConst
		{
			static constexpr bool value = !IsSame<T, RemoveConst_t<T>>::value;
		};

		/**
		 * @brief	Conditional type selection based on a boolean condition.
		 * @tparam	Condition The boolean condition.
		 * @tparam	T The type if the condition is true.
		 * @tparam	U The type if the condition is false.
		 */
		template<bool Condition, typename T, typename U>
		struct Conditional
		{
			using Type = T;
		};

		/**
		 * @brief	Conditional type selection specialization for false condition.
		 * @tparam	T The type if the condition is true.
		 * @tparam	U The type if the condition is false.
		 */
		template<typename T, typename U>
		struct Conditional<false, T, U>
		{
			using Type = U;
		};
	};
};
#endif // __REFLECTION_UTILS_H__